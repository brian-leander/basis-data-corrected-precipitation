package dk.dmi.lib.db;import dk.dmi.lib.gauges.*;//import locations.gauges.Geonor;//import locations.gauges.Pluvio;//import locations.gauges.Rimco;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Timestamp;import java.time.ZonedDateTime;import java.util.ArrayList;import java.util.TreeMap;import java.util.logging.Level;import java.util.logging.Logger;/** * Class containing methods for accessing ClimaDB in order to save the amount of * connections etc. * * * @author Kenan Vilic, kev@dmi.dk */public class ClimaDB extends Database {    private ArrayList<String> missing = new ArrayList<String>(15);    private static final Logger LOG = Logger.getLogger(ClimaDB.class.getName());    /**     * Constructor by default it connects to ClimaDB with Clipac settings     */    public ClimaDB() {        super("nanoqt.dmi.dk:5432/climadb", "thn", "thndmi", Database.POSTGRES);    }    public void writeMissing() {        for (String s : missing) {            System.out.println("" + s);        }    }    /**     * Constructor which can connect to ClimaDB with settings provided as     * arguments     *     * @param serverName server name. eg. nanow.dmi.dk:5432     * @param databaseName database name. eg. climadb     * @param userName user name. eg. kev     * @param password password. eg. pass     */    public ClimaDB(String serverName, String databaseName, String userName, String password) {        super(serverName + "/" + databaseName, userName, password, Database.POSTGRES);    }    /**     * Returns all 20km grid points stored in ClimaDB     *     * @return all 20km grid points     *///    public ArrayList<GridPoint> ReadGridpoints() {//        ArrayList<GridPoint> gps = new ArrayList<GridPoint>(200);//        try {//            String statement = "SELECT field_id, eastings, northings FROM work.ingres_grid_field_id_pos WHERE grid_size = '20km  '";////            PreparedStatement ps = getConnection().prepareStatement(statement);//            ResultSet r = ps.executeQuery();//            while (r.next()) {//                int fieldid = r.getInt("field_id");//                int eastings = r.getInt("eastings");//                int northings = r.getInt("northings");////                GridPoint gp = new GridPoint(fieldid, eastings, northings, 20000);////                gps.add(gp);////            }////        } catch (SQLException sqlex) {//            sqlex.printStackTrace();//        } catch (Exception ex) {//            ex.printStackTrace();//        }////        return gps;//    }    /**     * Returns precipitation stations for a single date     *     * @param date Zoned Date Time specifying the date     * @return et array der indeholder stationsnumre     */    public ArrayList<Station> getStations(ZonedDateTime date, TreeMap<Integer, String> statCode) {        ArrayList<Station> stats = new ArrayList<>(300);        try {        	String statement = "SELECT distinct(a.statid), a.elem_val, a.label, a.end_hour FROM "                    + "(SELECT statid, elem_val, label, end_hour from basis_daily_dk where "                    + "the_date = ? and elem_no = 601 order by statid) a ";                    //            String statement = "SELECT distinct(a.statid), a.elem_val, a.label, a.end_hour, b.vi_index FROM "////                    + "(SELECT statid, elem_val, label, end_hour from basis_daily_dk where "////                    + "the_date = ? and elem_no = 601 order by statid) "////                    + "a "////                    + " LEFT JOIN "////                    + "(select statid, vi_index "////                    + "from statcat.reference_stat_vinkler20170110 "////                    + "where start_time <= ? and (end_time > ? or end_time is null))"////                    + " b on a.statid/100=b.statid";            PreparedStatement ps = getConnection().prepareStatement(statement);            ps.setTimestamp(1, new Timestamp(date.toInstant().toEpochMilli()));            ResultSet r = ps.executeQuery();            while (r.next()) {                int statid = r.getInt("statid");                double value = r.getDouble("elem_val");                int label = r.getInt("label");                int end_hour = r.getInt("end_hour");                int leeindex = 0; //r.getInt("vi_index");                if (r.wasNull()) {                    LOG.log(Level.WARNING, "CorrectedPrecip:Main: Manglende laeindex til {0}", new Object[]{statid});                    if (!missing.contains("" + statid)) {                        missing.add("" + statid);                    }                } else {                    String code = statCode.get(new Integer(statid));                    GaugeConstants constants = null;                    if (code != null && (code.equals("PSVK") || code.equals("rimco"))) {//                        s = new Station(statid, value, leeindex, label, end_hour);                        constants = GaugeConstantsImpl.RIMCO;                    } else if (code != null && code.equals("geonor")) {//                        s = new Station(statid, value, leeindex, label, end_hour);                        constants = GaugeConstantsImpl.GEONOR;                    } else if (code != null && code.equals("pluvio")) {                        //s = new Pluvio(statid, value, leeindex, label, end_hour);                        constants = GaugeConstantsImpl.PLUVIO;                    }                    Station s = null;                    if (constants != null) {                        //s = new Pluvio(statid, value, leeindex, label, end_hour);                        s = new Station(statid, value, leeindex, label, end_hour, constants);                    }                    if (s == null) {                        LOG.log(Level.SEVERE, "Missing station code : " +statid);                    } else {                        stats.add(s);                    }                }            }        } catch (SQLException sqlex) {            sqlex.printStackTrace();        }        return stats;    }/*    public int updateBasisDailyDK(Station[] stats, GregorianCalendar gc) {        try {            String sqlStatement = "UPDATE basis_daily_dk SET (statid, the_date, elem_no, elem_val, label, end_hour, calc_date, ins_date) "                    + "= (?,?,?,?,?,?,now(),now()) "                    + "WHERE statid = ? AND the_date = ? AND elem_no = ?";            PreparedStatement ps = getConnection().prepareStatement(sqlStatement);            for (Station s : stats) {                ps.setInt(1, s.getId());                long l = gc.getTimeInMillis();                ps.setTimestamp(2, new Timestamp(l));                ps.setInt(3, 621);                ps.setDouble(4, (double) Math.round(s.getCorrected() * 10.0) / 10.0);                int label = s.getQualityStamp();                ps.setInt(5, label);                ps.setInt(6, s.getEndHour());                ps.setInt(7, s.getId());                ps.setTimestamp(8, new Timestamp(l));                ps.setInt(9, 621);                System.out.println("" + ps);                ps.addBatch();            }            int[] result = ps.executeBatch();            return 1;        } catch (SQLException ex) {            Logger.getLogger(ClimaDB.class.getName()).log(Level.SEVERE, null, ex);            Logger.getLogger(ClimaDB.class.getName()).log(Level.SEVERE, null, ex.getNextException());        }        return 0;    }    public void insertIntoBasisDailyDK(Station[] stats, GregorianCalendar gc) {        try {            String sqlStatement = "INSERT INTO basis_daily_dk (statid, the_date, elem_no, elem_val, label, end_hour, calc_date, ins_date) "                    + "VALUES(?,?,?,?,?,?,now(),now())";            PreparedStatement ps = getConnection().prepareStatement(sqlStatement);            for (Station s : stats) {                ps.setInt(1, s.getId());                long l = gc.getTimeInMillis();                ps.setTimestamp(2, new Timestamp(l));                ps.setInt(3, 621);                ps.setDouble(4, (double) Math.round(s.getCorrected() * 10.0) / 10.0);                int label = s.getQualityStamp();                ps.setInt(5, label);                ps.setInt(6, s.getEndHour());                System.out.println("" + ps);                if (s.getId() != 542720) {                    ps.addBatch();                }            }            ps.executeBatch();        } catch (SQLException ex) {            Logger.getLogger(ClimaDB.class.getName()).log(Level.SEVERE, null, ex);            Logger.getLogger(ClimaDB.class.getName()).log(Level.SEVERE, null, ex.getNextException());        }    }*/}